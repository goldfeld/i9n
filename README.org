* enlightened

A Clojure library designed to ... well, that part is up to you.

** Usage

FIXME

*** Navigation

The navigation widget is a very high-level, declarative way to build
list-based interfaces. The abstraction is that of interconnected menu
screens, which can nonetheless be far more interactive and
programmatic than a menu would normally be, thus the more general term
'navigation'.

It allows for UIs that are asynchronous, lazy and responsive through
the use of a simple core.async messaging protocol. It all starts with
passing a channel within the =cfg= parameter (a map), through its
=:chan= property. If that is not supplied, the navigation widget will
create its own channel internally which then won't be accessible to
the user.

This channel serves as the backbone of the navigation widget's loop,
as every operation (adding and modifying screens, moving from screen
to screen, among other more meta commands) is processed sequentially,
even as they're accepted asynchronously.

**** Operations

***** :next

Takes as first argument either the id of the screen to go next, or the
full nav-entry--that is, a vector with three elements: the id, the
title and a body. In this latter case, the nav-entry is added to the
hierarchy (or updated, if the id already exists.)

=:next= messages are the standard way to navigate the interface,
because it saves a link so you can go back to the previous screen. It
also optionally takes the list position in the current screen (default
to =0= if not supplied.), so that when going back you end up in the
position you left, which is very natural and even expected behavior in
navigation screens.

The third--also optional--argument is the list position to go to in
the next screen, defaulting to =0= as well. Going to a specific
position might be useful e.g. you're jumping to some search result.

***** :hop

Like =:next=, except it doesn't save a link to go back to, and so it
doesn't take =:next='s current position argument, instead taking an
optional position to go to as second and last argument. This also
makes it useful for hopping to another position within the same
screen.

Note that when using =:next= the new link created overwrites the
former link, since there can only be one meaning when you
press *back*. Here there's no overwriting, so if you hop to a random
screen, you might be able to back into a former connection that was
made to it when =:next= was used. This is precisely what happens in
the action of going back itself, which uses =:hop= for its internal
implementation. This allows you to go next many screens and then be
able to go all the way back.

***** :set

Like =:hop=, except that it must always take a full nav-entry as first
argument, never a screen id. A =:set= can be useful for setting the
interface to a temporary screen with a dummy id (say, =:temp= or
really anything, though not =nil=) that won't go into the hierarchy.

In reality I was lying and =:hop= is not used internally to implement
the action of going back screens. It's =:set= that's used, because
when a link is saved, the whole nav-entry is copied there, which
allows local, temporary state to be preserved for when you go back.
So this operation can be used for similar effect.

***** :fix

Updates nav-entries as surgically as you need, taking care to apply
your fixes both in the hierarchy (i.e. persist the changes) and in any
temporary state such as the user's current screen. It can be used to
replace, add or remove an option or part of it. Takes the id of the
screen to change as first argument, the =place= (where to change) as
second, and what to change as rest arguments.

****** =place= syntax

The most basic =place= designation is an integer (equal or greater
than zero--with a negative number the fix operation will be ignored),
which signifies a fix *starting* from that index. That means if you
give it =4= as the place and then supply four following arguments in
the =:fix= operation, the option starting at index =4= as well as the
one starting at index =6= will be changed--or added if those indexes
didn't exist.

The only way to change the title of an entry, as opposed to the
options of its body, is to use =:title= as the place. The table below
features other keywords accepted as a place. Note that *option* means
a pair of elements (label and action) from the body's vector, so
/option 3/ would start at index 6 and end at index 7.

| keyword        | place meaning                                              |
|----------------+------------------------------------------------------------|
| =:last=        | Last option's label, i.e. last /even/ index                |
| =:last-action= | Last option's action, i.e. very last index                 |
| =:pop=         | Removes the last option, takes no argument after the place |
| =:append=      | Adds after the last option                                 |
| =:prepend=     | Adds before the first option                               |

The append and prepend keywords above are useful in that they always
add new stuff, but what about adding to the middle of the list? The
next table shows vector-based place syntax, allowing you to do that
and other hopefully helpful things.

| syntax                  | place meaning                                      |
|-------------------------+----------------------------------------------------|
| =[:insert n]=           | Adds before the start of option =n=                |
| =[:insert-after & xs]=  | Adds after option matching any of elements =xs=    |
| =[:insert-before & xs]= | Adds before option matching any of elements =xs=   |
| =[:action n]=           | Changes action(s) of option(s) starting from /n/   |
| =[:label n]=            | Changes label(s) of option(s) starting from /n/    |
| =[:action-find & xs]=   | Like =:action= but from first matching any of =xs= |
| =[:label-find & xs]=    | Like =:label= but from first matching any of =xs=  |
| =[:from & xs]=          | Replaces from first option matching any of =xs=    |
| =[:after n & xs]=       | Like =:from= but starts /n/ options after          |
| =[:before n & xs]=      | Like =:from= but starts /n/ options before         |
| =[:shrink n start]=     | Remove /n/ options from option /start/             |
| =[:remove n & xs]=      | Remove /n/ options from first matching any of =xs= |

When there are several needles =xs= from which to find a matching
result in the haystack, each needle is first searched over the whole
haystack before trying the next one. Trying needles is less dangerous
than it sounds.

***** :put

Takes all the same arguments as =:fix=, but doesn't persist the fix
into the hierarchy. Thus, the fix is only applied to temporary state
nav-entries, such as the one representing the user's current screen.
If there is no such temporary state target where to apply the fix,
nothing is done by the =:put= operation.

***** :select

Example: =(a/put! in [:select 2])=

Select option at index /n/ in whatever screen is the current. Accepts
=:last= as an index.

***** :dirty

Example: =(a/put! in [:dirty :screen1 :screen4])=

Takes the id(s) of the screen(s) to be made dirty. Dirtying is
exclusively for the library user, to facilitate his keeping track of
which parts of the hierarchy will have to be lazily recomputed, if at
all, when they're finally accessed--this is coupled with passing a
=:flush= channel inside the =cfg= parameter's =:watches= property, on
which to listen to flush messages.

Even though dirtying could be managed externally by the user, building
it into the navigation loop takes care of a few things for you:

 1. a flush notification is sent out when a dirty screen is finally
    accessed, after first clearing the screen's dirty status;

 2. you can send in =:stub= messages, which are just like =:add=
    messages, except that the screen is created dirty, which means you
    lazily create just a stub, and wait for a flush message to finish
    building the screen only when it's first needed.
    
***** :state

Example: =(a/put! in [:state :user-setting1 :foo :user-setting2 :bar])=

Use for any application-specific state that you need to keep between
screens--globally in fact, stored within the =nav= object as a map
under the =:state= key.

Built-in user-facing facilities may interact with state to make the
use of state easier and more high-level than sending =:state=
messages; see =enlightened.os.navigation/pick-option= for example.

***** :column

Allows setting properties of columnar data in a given screen. Takes
the id of the screen as first argument and the integer index of the
column as second. The rest of the arguments should consist of pairs of
keyword and value (keyword arguments). All arguments are optional. The
keywords accepted are:

| keyword  | arguments type | description                                     |
|----------+----------------+-------------------------------------------------|
| =:width= | int            | Always keep col width at this character length. |
| =:sort=  | (fn [a b])     | Sort table by this col, using supplied fn.      |

** License

Copyright Â© 2014 Vic Goldfeld

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
